{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Helix \u00b6 Helix is a library written in Rust providing core features for getting your N64 software running on PC and other systems. Features Provided \u00b6 [ ] Window, GUI & Rendering (gui) (WIP) [x] Audio Playback (audio) [x] Speech Synthesis (speech) [x] TCP Stream (network) For details on each of the features provided please see our documentation . How to setup? \u00b6 For setup and more in-depth information please see our documentation .","title":"Overview"},{"location":"#helix","text":"Helix is a library written in Rust providing core features for getting your N64 software running on PC and other systems.","title":"Helix"},{"location":"#features-provided","text":"[ ] Window, GUI & Rendering (gui) (WIP) [x] Audio Playback (audio) [x] Speech Synthesis (speech) [x] TCP Stream (network) For details on each of the features provided please see our documentation .","title":"Features Provided"},{"location":"#how-to-setup","text":"For setup and more in-depth information please see our documentation .","title":"How to setup?"},{"location":"features/","text":"Features \u00b6 GUI \u00b6 Helix provides a GUI library for creating windows and rendering graphics. The GUI library is currently a work in progress and is not yet complete. ImGui / imgui-rs is used for drawing, if you\u2019re working on a C/C++ project, you\u2019ll need to include the ImGui headers to your project: // If C++ #include <imgui/imgui.h> // If C (make sure to set CIMGUI_DEFINE_ENUMS_AND_STRUCTS to 1) #include <cimgui/cimgui.h> The following API is provided: /** * Creates and sets up the event loop, returning a pointer to the instance or nullptr if creation failed **/ void * GUICreateEventLoop (); // Rust: let event_loop = Gui::create_event_loop(); /** * Creates the window and sets up the GUI, returning a pointer to the instance or nullptr if creation failed. * It takes two callbacks, one for drawing the menu and one for drawing the main screen and are called every frame. * ImGui is used for drawing, so you're free to use any ImGui functions in your callbacks. **/ void * GUICreate ( const char * title , void * event_loop , void ( * draw_menu_callback )(), void ( * draw_main_callback )()); // Rust: let mut gui = GUI::new(\"My Title\", &event_loop, draw_menu_callback, draw_main_callback).unwrap(); /** * Starts the rendering loop and returns when the window is closed. **/ void * GUIStart ( void * event_loop , void * gui ); // Rust: gui.start(); Audio \u00b6 Helix provides functionality for audio playback. Audio playback is simple and Helix provides the following API: /** * Creates and sets up the audio player, returning a pointer to the instance or nullptr if creation failed **/ void * HLXAudioPlayerCreate ( uint32_t sampleRate , uint16_t channels ); // Rust: let mut audio_Player = AudiPlayer::new().unwrap(); /** * Frees the audio player instance. **/ void HLXAudioPlayerFree ( void * player ); // Rust: no dedicated method, instance drop will deallocate it /** * Returns the amount of data currently in buffer. **/ int32_t HLXAudioPlayerGetBuffered ( void * player ); // Rust: audio_player.buffered() -> i32 /** * Returns the amount of data we want the buffer to contain. **/ int32_t HLXAudioPlayerGetDesiredBuffered ( void * player ); // Rust: audio_player.desired_buffer() -> i32 /** * Plays the audio from the given buffer - resampling if necessary for audio output device. **/ void HLXAudioPlayerPlayBuffer ( void * player , const uint8_t * buf , size_t len ); // Rust: audio_player.play_buffer(buf: &[u8]) Speech \u00b6 Helix provides an API for text-to-speech (TTS): /** * Creates and sets up the audio synthesizer, returning a pointer to the instance or nullptr if creation failed **/ void * SpeechSynthesizerCreate ( void ); // Rust: let mut speech_synthesizer = SpeechSynthesizer::new().unwrap(); /** * Frees the speech synthesizer instance. **/ void SpeechSynthesizerFree ( void * synthesizer ); // Rust: no dedicated method, instance drop will deallocate it /** * Sets the volume for the synthesizer, scale from 0-1. **/ void SpeechSynthesizerSetVolume ( void * synthesizer , float volume ); // Rust: speech_synthesizer.set_volume(volume: f32) /** * Sets the language of the speaker, takes in a en-US type locale. **/ void SpeechSynthesizerSetLanguage ( void * synthesizer , const char * language ); // Rust: speech_synthesizer.set_language(language: &str) /** * Sets the gender of the speaker, accepted values: SpeechSynthesizerGenderFemale/Male/Neutral. **/ void SpeechSynthesizerSetGender ( void * synthesizer , SpeechSynthesizerGender gender ); // Rust: speech_synthesizer.set_gender(gender: SpeechSynthesizerGender) /** * Dictates the given text, specifying whether previous utterances should be interrupted. **/ void SpeechSynthesizerSpeak ( void * synthesizer , const char * text , uint8_t interrupt ); // Rust: speech_synthesizer.speak(text: &str, interrupt: bool)","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#gui","text":"Helix provides a GUI library for creating windows and rendering graphics. The GUI library is currently a work in progress and is not yet complete. ImGui / imgui-rs is used for drawing, if you\u2019re working on a C/C++ project, you\u2019ll need to include the ImGui headers to your project: // If C++ #include <imgui/imgui.h> // If C (make sure to set CIMGUI_DEFINE_ENUMS_AND_STRUCTS to 1) #include <cimgui/cimgui.h> The following API is provided: /** * Creates and sets up the event loop, returning a pointer to the instance or nullptr if creation failed **/ void * GUICreateEventLoop (); // Rust: let event_loop = Gui::create_event_loop(); /** * Creates the window and sets up the GUI, returning a pointer to the instance or nullptr if creation failed. * It takes two callbacks, one for drawing the menu and one for drawing the main screen and are called every frame. * ImGui is used for drawing, so you're free to use any ImGui functions in your callbacks. **/ void * GUICreate ( const char * title , void * event_loop , void ( * draw_menu_callback )(), void ( * draw_main_callback )()); // Rust: let mut gui = GUI::new(\"My Title\", &event_loop, draw_menu_callback, draw_main_callback).unwrap(); /** * Starts the rendering loop and returns when the window is closed. **/ void * GUIStart ( void * event_loop , void * gui ); // Rust: gui.start();","title":"GUI"},{"location":"features/#audio","text":"Helix provides functionality for audio playback. Audio playback is simple and Helix provides the following API: /** * Creates and sets up the audio player, returning a pointer to the instance or nullptr if creation failed **/ void * HLXAudioPlayerCreate ( uint32_t sampleRate , uint16_t channels ); // Rust: let mut audio_Player = AudiPlayer::new().unwrap(); /** * Frees the audio player instance. **/ void HLXAudioPlayerFree ( void * player ); // Rust: no dedicated method, instance drop will deallocate it /** * Returns the amount of data currently in buffer. **/ int32_t HLXAudioPlayerGetBuffered ( void * player ); // Rust: audio_player.buffered() -> i32 /** * Returns the amount of data we want the buffer to contain. **/ int32_t HLXAudioPlayerGetDesiredBuffered ( void * player ); // Rust: audio_player.desired_buffer() -> i32 /** * Plays the audio from the given buffer - resampling if necessary for audio output device. **/ void HLXAudioPlayerPlayBuffer ( void * player , const uint8_t * buf , size_t len ); // Rust: audio_player.play_buffer(buf: &[u8])","title":"Audio"},{"location":"features/#speech","text":"Helix provides an API for text-to-speech (TTS): /** * Creates and sets up the audio synthesizer, returning a pointer to the instance or nullptr if creation failed **/ void * SpeechSynthesizerCreate ( void ); // Rust: let mut speech_synthesizer = SpeechSynthesizer::new().unwrap(); /** * Frees the speech synthesizer instance. **/ void SpeechSynthesizerFree ( void * synthesizer ); // Rust: no dedicated method, instance drop will deallocate it /** * Sets the volume for the synthesizer, scale from 0-1. **/ void SpeechSynthesizerSetVolume ( void * synthesizer , float volume ); // Rust: speech_synthesizer.set_volume(volume: f32) /** * Sets the language of the speaker, takes in a en-US type locale. **/ void SpeechSynthesizerSetLanguage ( void * synthesizer , const char * language ); // Rust: speech_synthesizer.set_language(language: &str) /** * Sets the gender of the speaker, accepted values: SpeechSynthesizerGenderFemale/Male/Neutral. **/ void SpeechSynthesizerSetGender ( void * synthesizer , SpeechSynthesizerGender gender ); // Rust: speech_synthesizer.set_gender(gender: SpeechSynthesizerGender) /** * Dictates the given text, specifying whether previous utterances should be interrupted. **/ void SpeechSynthesizerSpeak ( void * synthesizer , const char * text , uint8_t interrupt ); // Rust: speech_synthesizer.speak(text: &str, interrupt: bool)","title":"Speech"},{"location":"integration/","text":"Integration \u00b6 C/C++ Project \u00b6 If you\u2019re working on a C or C++ project the recommended way of integrating Helix into your project is using CMake. You can easily build and link this library by using Corrosion , a tool that integrate Rust libraries into C/C++ projects. You\u2019ll want to: Add this library as a submodule (or copy it) into your project Enable Corrosion using FetchContent (see their README) Include the features you want to be built using FEATURES . audio is always included. Link against the helix library Include the include folder of helix so your program can see the available methods NOTE: If you get a build error that certain header methods are not implemented, you\u2019re likely not building with that feature enabled. Example: corrosion_import_crate ( MANIFEST_PATH $ { CMAKE_CURRENT_SOURCE_DIR } / .. / helix / Cargo . toml FEATURES network ) # methods in these headers will work: # include <helix/network.h> , <helix/audio.h> # methods in these headers won't work: # include <helix/speech.h> Rust Project \u00b6 If you\u2019re working on a Rust project, you can add Helix via cargo add helix . Dependencies Required \u00b6 Linux \u00b6 libasound2-dev fontconfig, freetype, x11 speech-dispatcher (optional - feature: speech)","title":"Integration"},{"location":"integration/#integration","text":"","title":"Integration"},{"location":"integration/#cc-project","text":"If you\u2019re working on a C or C++ project the recommended way of integrating Helix into your project is using CMake. You can easily build and link this library by using Corrosion , a tool that integrate Rust libraries into C/C++ projects. You\u2019ll want to: Add this library as a submodule (or copy it) into your project Enable Corrosion using FetchContent (see their README) Include the features you want to be built using FEATURES . audio is always included. Link against the helix library Include the include folder of helix so your program can see the available methods NOTE: If you get a build error that certain header methods are not implemented, you\u2019re likely not building with that feature enabled. Example: corrosion_import_crate ( MANIFEST_PATH $ { CMAKE_CURRENT_SOURCE_DIR } / .. / helix / Cargo . toml FEATURES network ) # methods in these headers will work: # include <helix/network.h> , <helix/audio.h> # methods in these headers won't work: # include <helix/speech.h>","title":"C/C++ Project"},{"location":"integration/#rust-project","text":"If you\u2019re working on a Rust project, you can add Helix via cargo add helix .","title":"Rust Project"},{"location":"integration/#dependencies-required","text":"","title":"Dependencies Required"},{"location":"integration/#linux","text":"libasound2-dev fontconfig, freetype, x11 speech-dispatcher (optional - feature: speech)","title":"Linux"}]}